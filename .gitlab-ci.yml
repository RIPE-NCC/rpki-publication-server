stages:
  - build
  - package
  - deploy
  - security

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_PIPELINE_SOURCE == "external"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

include:
  - project: swe/gitlab-support
    file: /templates/security.yml
    inputs:
      stage: security
      needs: ["lockfile"]
  - project: swe/gitlab-support
    file: /templates/container.yml
    inputs:
      stage: security
      name: rpki-publication-server
      image: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
      dockerfile: Dockerfile
      needs: ["docker-image"]
  - project: swe/gitlab-support
    file: /templates/approval.yml
    inputs:
      stage: .post
      access-token: "$APPROVAL_BOT_ACCESS_TOKEN"

variables:
  DEBIAN_FRONTEND: noninteractive
  TERM: dumb

default:
  image: sbtscala/scala-sbt:eclipse-temurin-alpine-24.0.1_9_1.11.7_2.13.17

# Cache per repository (not shared between forks?).
cache: &global_cache
  key: one-key-for-all
  # In general, only pull the cache. pull-push in the stage that gathers all
  # artifacts.
  policy: pull
  paths:
    - "${CI_PROJECT_DIR}/.sbt"

lockfile:
  stage: .pre
  cache:
    <<: *global_cache
    policy: pull-push
  script:
    - sbt dependencyLockWrite
  artifacts:
    paths:
      - "build.sbt.lock"

build:
  stage: build
  services:
    - postgres:15
  variables:        
    POSTGRES_PASSWORD: postgres
    POSTGRES_USER: pubserver  
    POSTGRES_DB: pubserver_test
    POSTGRES_HOST_AUTH_METHOD: trust
    POSTGRES_URL: "jdbc:postgresql://postgres:5432/pubserver_test"
  cache:
    <<: *global_cache
  before_script:
    - apk add --no-cache postgresql-client
    - psql -h postgres -U ${POSTGRES_USER} ${POSTGRES_DB} -c 'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";'    
  script:
    - sbt compile test universal:packageZipTarball
  artifacts:
    paths:
      - target/rpki-publication-server-*.jar
    reports:
      junit:
        - target/test-reports/*.xml
    expire_in: 4 weeks

# All the package stages only require the test job, so whitesource scanning can
# progress in parallel since this takes up to ten minutes.
docker-image:
  image: docker:29.1-cli
  services:
    - docker:29.1-dind
  stage: package
  needs: ["build"]
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - cp target/rpki-publication-server-*.jar rpki-publication-server.jar
    - docker build --build-arg JAR_FILE=rpki-publication-server.jar --label org.label-schema.vcs-ref="$CI_COMMIT_SHORT_SHA" --tag "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

release:latest:
  image: docker:29.1-cli
  services:
    - docker:29.1-dind
  stage: deploy
  needs: ["docker-image"]
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: never

#
# Update a Salt-managed container with a new version of an image.
#
# Deploying a new image for a Salt-managed container requires retagging the new
# image with a fixed tag that matches the tag in pillar configuration
# (e.g. ':latest' or the name of the environment).
#
# Then Salt must apply the 'docker' target on the system with
# `update_containers` set. This will pull the new image, stop the old container
# and start a new one.
#
# The following variables are required as input for this job.
#
# - IMAGE: image to deploy
# - READINESS_URL: URL returning 200 Ok when the container is ready
# - SALT_API_PASSWORD: Password for Salt API
# - SALT_API_URL: URL of the API to control Salt master
# - SALT_API_USERNAME: Username for Salt API
# - TARGET_CONTAINER: name of the container to deploy
# - TARGET_HOST: host system that runs the container
# - TARGET_TAG: tag used on the target host
#
.salt-container-deploy: &salt-container-deploy
  image: docker-registry.ripe.net/swe/gitlab-ci/debian-deployenv
  stage: deploy
  script:
    - if [ -z "${TARGET_CONTAINER}" ]; then echo "set TARGET_CONTAINER"; exit 2; fi
    - if [ -z "${IMAGE}" ]; then echo "set IMAGE"; exit 2; fi
    - if [ -z "${READINESS_URL}" ]; then echo "set READINESS_URL"; exit 2; fi
    - if [ -z "${SALT_API_URL}" ]; then echo "set SALT_API_URL"; exit 2; fi
    - if [ -z "${TARGET_HOST}" ]; then echo "set TARGET_HOST"; exit 2; fi
    - if [ -z "${TARGET_TAG}" ]; then echo "set TARGET_TAG"; exit 2; fi

    - echo "Logging into ${CI_REGISTRY}"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"

    - echo "Retagging '${IMAGE}' as '${IMAGE/:*/}:${TARGET_TAG}'"
    - docker pull "${IMAGE}"
    - docker tag "${IMAGE}" "${IMAGE/:*/}:${TARGET_TAG}"
    - docker push "${IMAGE/:*/}:${TARGET_TAG}"

    - echo "Logging into salt-api"
    - >
      curl -ik ${SALT_API_URL}/login \
        -c ./cookies.txt \
        -H 'Accept: application/x-yaml' \
        -d username="${SALT_API_USERNAME}" \
        -d password="${SALT_API_PASSWORD}" \
        -d eauth='ldap'

    - echo "Updating '${TARGET_CONTAINER}' container via salt on ${TARGET_HOST}"
    - >
      curl -D "/dev/stderr" -k "${SALT_API_URL}" \
        -b ./cookies.txt \
        -H 'Content-type: application/json' -d"
            [{
              \"timeout\": 120,
              \"failhard\": \"True\",
              \"client\": \"local_batch\",
              \"batch\": \"25%\",
              \"fun\": \"state.apply\",
              \"tgt_type\": \"glob\",
              \"tgt\": \"${TARGET_HOST}\",
              \"arg\": [\"docker\"],
              \"kwarg\": {
                \"pillar\": {
                  \"update_containers\": true
                }
              }
            }]
            " | jq -R '. as $raw | try fromjson catch $raw'

deploy:prepdev:
  <<: *salt-container-deploy
  needs: ["docker-image"]
  variables:
    IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    TARGET_CONTAINER: rpki-publication-server
    READINESS_URL: http://127.0.0.1:8080/monitoring/healthcheck
    TARGET_TAG: prepdev
  parallel:
    matrix:
      - TARGET_HOST: publish-4.rpki.prepdev.ripe.net
        PUBSERVER_URL: http://publish-4.rpki.prepdev.ripe.net:8080/monitoring/healthcheck
      - TARGET_HOST: publish-5.rpki.prepdev.ripe.net
        PUBSERVER_URL: http://publish-5.rpki.prepdev.ripe.net:8080/monitoring/healthcheck
  environment:
    name: prepdev
    url: "$PUBSERVER_URL"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: manual

deploy:production:
  <<: *salt-container-deploy
  needs: ["docker-image"]
  variables:
    IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    TARGET_CONTAINER: rpki-publication-server
    READINESS_URL: http://127.0.0.1:8080/monitoring/healthcheck
    TARGET_TAG: production
  parallel:
    matrix:
      - TARGET_HOST: publish-4.rpki.ripe.net
        PUBSERVER_URL: http://publish-4.rpki.ripe.net:8080/monitoring/healthcheck
      - TARGET_HOST: publish-5.rpki.ripe.net
        PUBSERVER_URL: http://publish-5.rpki.ripe.net:8080/monitoring/healthcheck
  environment:
    name: production
    url: "$PUBSERVER_URL"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: never

